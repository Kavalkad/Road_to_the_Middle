---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
date: 2025-08-30
завершена: true
---
## Общая информация
---
***Интерфейс*** по сути представляет собой *набор сигнатур методов*. В интерфейсах можно также описать *делегаты*, *события* и *свойства*, т.к. эти члены представляют собой *синтаксический сахар*, за которым стоят <u>методы</u>.

Для определения интерфейса в C# используется ключевое слово ***interface***. 
С точки зрения CLR определение интерфейса почти ***то же, что и определение типа***. Поэтому информацию об членах интерфейса можно получить через отражение. 

Как и типы, ***интерфейсы*** могут быть вложенными в класс или иметь определённый ***уровень доступа***. При определении интерфейса можно указать требуемую область видимости или доступа (`public`, `protected` и др.)

В соответствии с соглашением ***имена*** интерфейсных типов начинаются с буквы ***I***, что облегчает их поиск в исходном коде.

Компилятор C# требует, чтобы ***метод, реализующий интерфейс***, был помечен модификатором ***public***. 

>[!idea]+ Внимание!
>Производный класс не может переопределять интерфейсные методы, но может повторно наследовать нужный интерфейс и предоставить собственную реализацию интерфейса.
## Вызов интерфейсных методов
---
CLR допускает использование интерфейсных полей, параметров или локальных переменных, имеющих интерфейсный тип. Используя переменную интерфейсного типа можно обратиться к методам, определённым этим интерфейсом.
```
// Переменная s ссылается на объект типа String
String s = "Andy";
// Используя s можно использовать любой метод, определённый в String, Object, IClonable, IEnumerable, IComparable и др.

// Переменная cloneable ссылается на объект s
ICloneable cloneable = s;
// Но через переменную cloneable можно получить доступ к методам интерфейса ICloneable (или любому методу, определённому в классе Object).

// Переменная comp ссылается на тот же объект s.
IComparable comp = s;
// Но через переменную comp можно получить доступ только к методам, интерфейса IComparable (или любому методу, определённому в классе Object).
```

>[!idea]+ Внимание!
>Интерфейсную переменную можно приводить к интерфейсу другого типа, если класс переменной реализует оба интерфейса. Сказанное демонстрирует код:
>```
>String s = "Andy";
>
>ICloneable cloneable = s;
>
>IComparable comp = (IComparable) cloneable;
>```
>То есть в переменной `s` хранится объект типа `String`. Этот тип реализует интерфейсы `IComparable` и `ICloneable`, поэтому мы можем привести переменную `cloneable` типа `ICloneable` к типу `IComparable`.

Как и ссылочный, **значимый тип может реализовывать нуль или больше интерфейсов**. Но при приведении переменной значимого типа к интерфейсному произойдёт ***упаковка*** значимой переменной, потому что интерфейсная переменная должна быть ссылкой, указывающей на объект в куче, чтобы CLR смогла проверить указатель и проверить тип объекта.
## Явные и неявные реализации интерфейсных методов
---
Рассмотрим такой код:
![[Pasted image 20250830094211.png]]
Здесь определён класс `SomeClass`, который реализует интерфейс `IDisposable`. В методе `Main()` сначала вызывается метод `Dispose()` класса `SomeClass`, затем переменная `sc` приводится к интерфейсному типу `IDisposable` и вызывается метод `Dispose()` интерфейса `IDisposable`. 

Для упрощения жизни программистам компилятор считает, что реализованный в классе метод `Dispose()` является реализацией интерфейсного метода `Dispose()`. Это возможно, потому что интерфейсный метод и метод, определённый в классе `SomeClass`, имеют одинаковые сигнатуры. На выходе получим такой вывод:
```
Метод Dispose() класса SomeClass
Метод Dispose() класса SomeClass
```

Теперь немного изменим класс `SomeClass` следующим образом:
![[Pasted image 20250830094436.png]]
Мы добавили метод `void IDisposable.Dispose()`. 
В C# если перед названием метода указать имя интерфейса, в котором определён этот метод, то создастся ***явная реализация интерфейсного метода*** (Explicit Interface Method Implementation, *EIMI*). 

>[!idea]+ Внимание!
>При ***явной реализации*** интерфейсного метода ***нельзя указывать уровень доступа***. Однако когда компилятор создаёт метаданные для этого метода, то он неявно ***пометит метод как закрытый*** ( ***private*** ), что запрещает любому коду использовать экземпляр класса для вызова интерфейсного метода. Использовать интерфейсный метод ***можно только*** через переменную ***этого интерфейсного типа***.

Обрати внимание на то, что явно реализованный интерфейсный метод ( *EIMI* ) не может быть виртуальным. Это объясняется тем, что интерфейсный метод считается не частью типа, а лишь средством связывания типа с интерфейсом.
## Обобщённые интерфейсы
---
Поддержка обобщённых интерфейсов открывает для разработчиков много интересных возможностей.

**Во-первых**, обобщённые интерфейсы позволяют обеспечить ***безопасность типов на этапе компиляции***. Некоторые интерфейсные методы принимают или возвращают тип `Object`. При вызове таких методов в качестве аргумента можно передать переменную ***любого типа, что нежелательно***.
Сказанное выше демонстрирует код:
![[Pasted image 20250830123844.png]]
В результате выполнения данного кода получим исключение:
![[Pasted image 20250830123719.png]]
Желательно обеспечить ***более строгий контроль типов*** в интерфейсном методе, поэтому в FCL есть обобщённая версия ***IComparable<.T>***. Исправим код использованием обобщённого интерфейса:
![[Pasted image 20250830124353.png]]

**Второе преимущество** использования обобщённых интерфейсов заключается в отсутствии необходимости упаковки переменных значимых типов. На скрине выше используется обобщённый интерфейс `IComparable<int>`. В переменную `c` передаётся переменная значимого типа `int` без упаковки. Затем в следующей строчке при вызове метода `CompareTo(int? arg)` обобщённого в качестве аргумента ожидается переменная типа `int?`.

>[!idea]+ Внимание!
>Тип `int?` относится к ***Null-совместимым типам***, которые рассмотрены в заметке [[099. Null-совместимые типы]].

Таким образом, благодаря использованию обобщённого интерфейса мы избавились от двух операций упаковки.

**Третье преимущество** заключается в том, что класс может реализовывать интерфейс многократно, просто используя параметры различного типа. 
Сказанное демонстрирует код:
![[Pasted image 20250830131346.png]]
Здесь класс `Number` реализует интерфейс `IComparable<T>` дважды, сначала в качестве параметра выступает тип `int`, затем – `string?`. 

>[!idea]+ Внимание!
>Параметры интерфейса могут быть помечены как ковариантные и контравариантные. Про ковариантность и контравариантность рассказано в [[010. !!!Обобщения]].
## Обобщения и ограничения интерфейса
---
В этой главе будут рассмотрены преимущества ограничений параметров-типов обобщённых интерфейсов.

1. **Первое преимущество** заключается в том, что параметр-тип ***можно ограничить несколькими интерфейсами***. В этом случае параметр-тип должен реализовывать *все* ограничения. 
   Сказанное выше отражает код: 
   ![[Pasted image 20250830165038.png]]
   В метод `M...` можно передать только параметр, который реализует интерфейсы `IComparable` и `IConvertible`. Класс `int` реализует ***оба эти интерфейса***, поэтому при вызове `M<int>(x)` ошибки не возникает. Класс `Guid` реализует ***только интерфейс*** `IComparable`, поэтому получаем ошибку на этапе компиляции. Полностью ошибка выглядит так:
   ***The type `System.Guid` cannot be used as type parameter `T` in the generic type or method `Program.SomeClass.M<T>(T)`. There is no boxing conversion `System.Guid` to `System.IConvertible`***. 
   
   2. **Второе преимущество** заключается в ***избавлении от упаковки*** при работе со ***значимыми типами***. В приведенном выше коде, если в методе `M<T>(T t)` вызвать метод `t.CompareTo()`, то упаковка не произойдёт, но может произойти упаковка параметра метода `CompareTo()`.
   
   >[!idea]+ Внимание!
   >Для ограничений компилятор C# генерирует IL-команды, которые вызывают ***интерфейсный метод*** для значимого типа ***напрямую, без упаковки***. Кроме использований ограничений ***нет другого способа*** заставить компилятор генерировать такие команды. Следовательно, остаётся единственное решение – ***использование ограничений обобщённых интерфейсов***.

## Реализация нескольких интерфейсов с одинаковыми сигнатурами и названиями интерфейсных методов
---
Иногда нужно определить тип, реализующий несколько интерфейсов с одинаковыми названиями и сигнатурами интерфейсных методов. 
Предположим, есть 2 интерфейса:
![[Pasted image 20250830171502.png]]
У нас есть 2 разных интерфейса с одинаковыми сигнатурами и названиями методов, а именно `void GetMenu()`. 
Для решения этой проблемы надо в явном виде реализовать методы обоих интерфейсов, как показано ниже:
![[Pasted image 20250830171658.png]]
Тогда вызов методов `GetMenu()` выглядит так:
![[Pasted image 20250830171946.png]]
И получим такой вывод:
![[Pasted image 20250830172008.png]]
## Шпаргалка
---


   
   
