---
tags:
  - CSharp
  - IT
Источник: Статья "Делегаты и с чем их едят". Блог компании OTUS
date: 2025-08-28
завершена: true
---
## Общая информация
---
Делегат – это по сути ссылка на метод. Если говорить техническим языком, то делегат – типобезопасный указатель на функцию. То есть делегат хранит ссылку на метод, позволяя вызвать этот метод без необходимости вызова напрямую.

**Определение**: Делегат – переменная ссылочного типа, которая может хранить ссылку на метод.
**Типобезопасность**: Делегаты очень конкретны в том, на что они могут ссылаться. При попытке использовать делегат, который предназначен для метода, *принимающего строку* и *возвращающего число*, с методом, который *принимает число* и *возвращает строку*, программа даже не скомпилируется.

**Синтаксис**: Аналогичен объявлению метода в интерфейсе с добавлением ключевого слова ***delegate***.

## Пример использования делегатов
---
Представим, что у нас есть спутниковая система, обрабатывающая информацию от далёких звёзд. После обработки данных системе необходимо уведомить базовую станцию на Земле:
```
public delegate void CosmicDataProcessedCallBack(string message);

class Program {
	
	static void Main(string[] args) {
		var satellite = new Satellite();
		satellite.ProcessStarData(NotifyBaseStation);
	}
	static void NotifyBaseStation(string notificationMessage){
		Console.WriteLine($"Базовая станция получила {notificationMessage}.");
	}
}
class Satellite {
	public void ProcessStarData(CosmicDataProcessedCallBack callback){
		System.Threading.Thread.Sleep(3000); // Имитирование работы
		callback("Данные от Альфа Центавры успешно обработаны.");
	}
}
```
В данном примере:
1. Спутник обрабатывает данные.
2. После обработки данных вызывается метод `ProcessStarData` объекта `satellite` класса `Satellite`.
3. В методе `ProcessStarData` используется функция обратного вызова
   (`CosmicDataProcessedCallBack`), которая принимает строку `Данные от Альфа Центавры успешно обработаны`.
## Типы делегатов
---
### Одиночные делегаты: 
   Одиночные делегаты напоминают корабли-одиночки для решения одной задачи.
   ```
   // Объявление делегата
   public delegate void LogMsg(string message);
   //
   public void DisplayStarInfo(string star) {
	   Console.WriteLine($"Наблюдаем звезду: {star}.")
   }
   LogMsg lm = DisplayStarInfo;
   lm("Альфа Центавра");
   // Вывод: Наблюдаем звезду: Альфа Центавра.
```

### Групповые делегаты:
   Групповые делегаты используются для выполнения заранее определённой цепочки действий. Например, при обнаружении астероида включается защитная система космического корабля.
   ```
   public delegate void AsteroidProtect();

	public void DetectAsteroid() {
		Console.WriteLine("Астероид обнаружен!").
	}
	
	public void ActivateShields() {
		Console.WriteLine("Активируем защитные щиты!");
	} 
	AsteroidProtect ap = DetectAsteroid;
	ap += ActivateShields;
	ap.Invoke();
```

Перед рассмотрением третьей группы делегатов (`Action`, `Func` и `Predicate`) предлагаю рассмотреть некоторые методы и свойства мультикастовых делегатов.
#### Метод GetInvocationList()
---
Прототип метода выглядит следующим образом:
```
public sealed override Delegate[] GetInvocationList()
```
То есть метод выводит ***массив типов делегатов***.
![[Pasted image 20250828193453.png]]
и следствием выполнения такого кода будет вывод:
![[Pasted image 20250828194653.png]]
#### Invoke()
---
Для вызова методов делегата используется метод ***Invoke()***. Однако, если переменная типа делегата содержит в себе значение ***null***, то при обращении к этой переменой будет выброшено исключение ***NullReferenceException***. Чтобы не выбросилось исключение, используй оператор `?.`. Таким образом, если делегат содержит ***null***, исключение *не будет выброшено*, просто ничего не будет. 

### Универсальные делегаты. Action, Func и Predicate
---
#### Action<.in T>
---
В нашей космической аналогии ***Action*** похож коммуникационный спутник, передающий сигналы без ожидания обратной связи. В угловых скобках можно задать только типы входных параметров, потому что, т.е. делегат `Action<int> MeActionDelegate` соответствует объявлению `delegate void MyActionDelegate(int x);`. Прототип делегата ***Action*** выглядит так:
```
public delegate void Action<in T ... in Tn>(T obj)
```

>[!idea]
>Конструкция `in T` рассматривается в теме [[010. !!!Обобщения]] по заголовку Дж. Рихтер CLR via C#.

Пример использования делегата ***Action*** в нашей космо-вселенной выглядит так:
```
Action<string> BroadcastSignal = (message) => 
{
	Console.WriteLine($"Трансляция: {message}");
};
BroadcastSignal("Мир и процветание всем существам!"); // Вывод: 
"Трансляция: Мир и процветание всем существам!"
```
#### Func<.in T, out TResult> 
---
***Func*** – исследовательское судно, предназначенное для сбора и возврата конкретных данных. В сигнатуре ***Func*** в угловых скобках мы задаём типы входных и выходного параметра, который всегда идёт последним в списке. Прототип метода выглядит следующим образом:
```
public delegate TResult Func<in T, ... out TResult>(T arg);
```

>[!idea]
>Конструкция `out TResult` рассматривается в теме [[010. !!!Обобщения]] в книжке по заголовку Дж. Рихтер CLR via C#.

#### Predicate<.in T>
---
***Predicate*** – спутник, специально разработанный для получения входной информации и вывода значения ***да/нет*** (*boolean*). 
Прототип делегата ***Predicate*** выглядит следующим образом:
```
public delegate bool Predicate<in T>(T obj)
```

Пример использования ***Predicate***:
```
Predicate<string> IsNebula = (celestialObject) => 
{
	return celestialObject.Contains("Туманность");
};
bool result = IsNebula("Туманность Ориона");
Console.WriteLine(result);  // Вывод: true
```
## Ошибки при использовании делегатов
---
**1. Чрезмерная подписка на событие**:
В нашей космической аналогии представь корабль, который получает слишком много сигналов одновременно. Это может привести к сбою. Так и у нас, если подписаться *одним* методом *несколько раз* на событие, то при вызове события метод будет вызван *несколько раз*. 

>[!idea]+ Идея
>Всегда проверять, что мы подписались на событие ровно столько раз, сколько нужно (чаще всего *один* раз.

**2. Утечка памяти с делегатами**
Если объекты подписались на событие и не отписались, то сборщик мусора не сможет их собрать, что приведёт к утечке памяти.

>[!idea]+ Идея
>Всегда отписывайся от события, чтобы обеспечить правильный сбор мусора.

## Итог
---
***Делегаты*** – мощный инструмент, позволяющий избавиться от множества конструкций с `if` и конструкций `switch`, что сокращает количество кода и соответствует принципу <font color="#de7802">DRY</font> (см. [[Принципы разработки. SOLID, DRY, KISS и YAGNI]].
