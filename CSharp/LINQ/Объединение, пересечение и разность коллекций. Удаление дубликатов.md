---
tags:
  - CSharp
  - IT
Источник: METANIT
date: 2025-09-05
завершена: true
---

## Объединение коллекций
---
Для объединения двух коллекций можно использовать метод ***`Union()`***. Результатом использования этого метода является коллекция из элементов первой и второй последовательности, при этом повторяющиеся элементы будут добавлены в коллекцию только *один* раз.
```
var names = new List<string>() { "Andy",  "Wend",  "Andy" };
var names2 = new List<string>() { "Andy", "John", "Edward", "Wend" };

var unames = names.Union(names2);

foreach (var n in unames)
{
	Console.WriteLine(n);
}
```
В результате получим такой вывод:
```
Andy
Wend
John
Edward
```
Если нам просто надо объединить две коллекции и всё равно на дубликаты, то можно использовать метод ***`Concat()`***.

>[!idea]+ Идея
>Последовательное использование методов `Concat()` и `Distinct()`(который рассмотрен ниже) аналогично использованию метода `Union`.
>
## Разность коллекций
---
С помощью метода ***`Except()`*** можно получить разность двух коллекций. Вернуть разность коллекций означает вернуть коллекцию элементов, которые есть в первой коллекции, и которых нет во второй. 
```
var names1 = new List<string>() { "Andy", "Candy", "Wend", "Pepperoni", "Banana" };
var names2 = new List<string>() { "Andy", "John", "Edward", "Wend", "Banana" };

var exceptNames = names1.Except(names2);

foreach (var name in exceptNames) 
{
	Console.WriteLine(name);
}
```
В результате получим такой вывод:
```
Candy
Pepperoni
```
## Пересечение коллекций
---
*Пересечение* коллекций – это коллекция элементов, которые *есть и в первой и во второй коллекции*. Пересечение коллекций можно получить использовав метод ***`Intersect()`***.
Найдём пересечение двух коллекций из предыдущего примера:
```
var exceptNames = names1.Intersect(names2);

foreach (var name in exceptNames) 
{
	Console.WriteLine(name);
}
```
В результате получим такой вывод:
```
Andy
Wend
Banana
```
## Удаление дубликатов
---
Для удаления дубликатов из коллекций используется метод ***`Distinct()`***. 
```
var names = new List<string>() { "Andy", "Wend", "Andy", "John", "Edward", "Wend", "Banana" };

var dnames = names.Distinct();

foreach (var n in dnames)
{
	Console.WriteLine(n)
}
```
Запустив код получим такой вывод:
```
Andy
Wend
John
Edward
Banana
```
## Работа с объектами пользовательского типа
---
Для сравнения объектов в последовательностях применяются методы ***`GetHashCode()`*** и ***`Equals()`***, поэтому применение LINQ возможно, если в описании класса или структуры имеются переопределённые методы ***`GetHashCode()`*** и ***`Equals()`***.
Реализация этих методов выглядит примерно так:
```
public string? Name;
public override int GetHashCode()
{
	return Name.GetHashCode();
}
 public override bool Equals(object? obj)
{
	if (obj is Person person) return Name == person.Name;
	return false;
}
```
