---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
завершена: true
---
Свойства позволяют использовать упрощённый синтаксис для доступа к методам. CLR поддерживает 2 вида свойств: свойства ***без параметров(a.k.a. обычные свойства)*** и свойства ***с параметром(a.k.a. индексаторы)***. 
## Свойства без параметров
---
Во многих типах определяется информация, которую можно прочитать или изменить. Часто это информация представлена полями:
```
public sealed class Employee {
	public String Name;
	public Int32 Age;
}
```
Создавая экземпляр класса Employee можно получать или изменять информацию об объекте с помощью такого кода:
```
var e = new Employee()'
e.Name = "Andy";
e.Age = 23;
```
Однако такой код нарушает одну из основ ООП – инкапсуляцию, потому что можно легко изменить значение поля на некорректное, что приведёт к ошибке в работе программы, например, таким кодом:
```
e.Age = -5; // Возраст не может иметь значение меньше 0
```

>[!idea]+ Инкапсуляция
>Инкапсуляция означает, что поля не в коем случае не следует открывать для общего доступа. Подробнее про ***инкапсуляцию*** см. [[ООП]].

Давайте перепишем наш код, чтобы он соответствовал принципу ***инкапсуляции***:
```
public sealed class Employee {
	private String _name;
	private Int32 _age;
	
	public String GetName() {
		return _name;
	}
	public void SetName(string name) {
		_name = name;
	} 
	public Int32 GetAge() {
		return _age;
	}
	public void SetAge(Int32 age) {
		if (age < 0) {
			throw new ArgumentOutOfRangeException("value", age.ToString(),
				"Age cannot be less then 0");
		}
		_age = age;
	}
}
```
Теперь наш код соответствует принципу инкапсуляции данных, но для этого нам пришлось написать дополнительно 4 метода. Для сокращения такого кода в C# были введены ***свойства*** для модификации доступа к полям. Свойства имеют 2 акссессора: ***get*** и ***set*** для получения и записи значения соответственно. Теперь перепишем наш код с использованием ***свойств***.
```
public sealed class Employee {
	private String _name;
	private Int32 _age;
	
	public String Name {
		get { return _name; }
		set { _name = value; }
	}
	public Int32 Age {
		get { return _age; }
		set { 
				if (value < 0){
					throw new ArgumentOutOfRangeException("value", value.ToString(), 
					"Age cannot be less than 0");
				}
			_age = value;
		}
	}
}
```
После компиляции свойства будут преобразованы в 2 метода: ***get_ИмяПоля*** и ***set_ИмяПоля*** для доступа и чтения значения поля. В результате 2 варианта кода, приведённые выше, будут преобразованы в одинаковый IL-код. Свойства могут иметь и один из двух акссессоров. Если свойство имеет только ***get***, то оно служит только для чтения, если только ***set***, то только для записи. Свойства также могут быть *экземплярными* (***по умолчанию***), *статичными* (***static***). 

С# также поддерживает механизм <font color="#de7802">автоматически реализуемых свойств</font>. В коде они выглядят вот так:
```
public String Name { get; set; }
```

>[!idea]
>Свойства являются "***синтаксическим сахаром***" для доступа к приватным полям объекта или класса.
## Свойства с параметрами
---
Свойства с параметрами в C# называются ***индексаторами***. В коде описание индексатора выгляди так:
```
public Point this[int i] {...}
```
По сути индексатор – это способ перегрузки оператора `[]`. 

Индексаторы, как и обычные свойства имеют два акссессора: ***get*** и ***set*** для получения и записи значения соответственно.  
Компилятор C# не различает свойства с параметрами и без параметров, потому что и для тех, и для других генерирует одинаковый IL-код. 

>[!idea]
>В основе индексатора зачастую лежит коллекция.

## Доступность методов доступа свойств
---
Иногда при проектировании свойств необходимо указать разные уровни доступа для получения и записи значения. Чаще всего используется открытый акссессор `get` и закрытый акссесор `set`:
```
public class SomeType {
	private String _name;
	public String Name {
		public get {
			return _name;
		}
		protected set {
			_name = value;
		}
	}
}
```

>[!attention]+ Внимание!
>При определении свойства с различным уровнем доступа к методам `get` и `set` C# требует, чтобы свойство имело более открытый уровень доступа, чем самый закрытый акссессор, и только один акссессор может иметь закрытый уровень доступа. В приведенном выше примере свойство (`Name`) имеет менее строгий уровень доступа (`public`), и только один акссессор (`set`) имеет более строгий уровень доступа (`protected`), соответственно второй акссессор (`get`) имеет уровень доступа такой же, как и свойство (`public`). 

## Анонимные типы
---
Механизм анонимных типов в C# позволяет создавать экземпляры кортежных типов посредством упрощённого синтаксиса:
```
var o1 = new { Name = "Andrew", Year = 2001 };
```
Здесь я создал экземпляр ***анонимного типа***, который имеет свойство `Name` и `Year` со значениями `"Andrew"` и `2001` соответственно. Тип называется ***анонимным***, потому что я не использовал никакое название класса. 

>[!idea]
>Для создания экземпляров анонимного типа можно использовать синтаксис неявной типизации (ключевое слово `var`).

Что же происходит под капотом на самом деле? Рассмотрим следующий код:
```
var o = new { property1 = expression1, property2 = expression2 ... propertyN = expressionN }
```
При чтении данного кода компилятор проанализирует типы значений, для каждого значения создаст ***открытое*** свойство, для каждого свойства создаст ***закрытое*** поле только для чтения (***readonly***) и создаст конструктор для каждого поля. Также компилятор переопределит методы ***Equals()***, ***GetHashCode()*** и ***ToString()***. 

>[!idea]
>Если создать несколько анонимных типов с одинаковыми типом и названиями свойств, то компилятор объединит их в один класс и создаст несколько экземпляров этого класса. А если две переменные относятся к одному типу, можно присвоить одной переменной значение другой, создать массив объектов анонимного типа.
>

Анонимные типы обычно используются с технологией ***языка интегрируемых запросов*** (см. [[099. LINQ]]), когда в результате выборки создаётся коллекция объектов анонимного типа, после чего производится обработка объектов в полученной коллекции. В приведенном ниже примере производится выборка документов, написанных в течении 7-ми дней, из данной папки:
```
String myDocuments = 
	Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
var query =
			from pathname in Directory.GetFiles(myDocuments)
			let LastWriteTime = File.GetLastWriteTime(pathname)
			where LastWriteTime > DateTime.Now - TimeSpan.FromDays(7)
			orderby LastWriteTime
			select new { Path = pathname, LastWriteTime };
```

