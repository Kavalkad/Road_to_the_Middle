---
tags:
  - IT
date: 2025-09-01
источник: Ulbi TV, Общие знания
завершена: true
---
## Общая информация
---

Парадигма ***ООП*** возникла как альтернатива *процедурному программированию*. Процедурное программирование выглядит так:
![[Pasted image 20250901152344.png]]
То есть имеются какие-то переменные, с ними выполняется *процедура*. 

Но таким образом написать большие приложения очень (прям очень) тяжело. Поэтому, когда процедурного программирования стало недостаточно, был придуман ***объектно-ориентированный подход*** (***ООП***).

В ***ООП*** всё представлено в виде *объектов*. Объекты имеют *характеристики* (поля, свойства), и *методы* (действия). Код, соответствующий ООП, выглядит примерно так:
![[Pasted image 20250901153739.png]]
ООП зиждется на трёх столпах: *инкапсуляция* (и рядышком следует *сокрытие*), *наследование* и *полиморфизм*.  Рассмотрим их подробнее.
## Инкапсуляция и сокрытие 
---
Согласно концепции инкапсуляции описание объектов представлено в виде "капсул" (классов, интерфейсов, и т.д.) в которых содержатся "свойства". Эта концепция кажется очевидной, но если взглянуть на функциональное программирование, то всё станет на свои места. 

***Сокрытие*** заключается в ограничении доступа и сокрытия реализации методов, свойств и других членов типа. Для ограничения доступа в C# имеются модификаторы доступа, которые описаны в заметке [[Основные сведения о членах и типах]]. Сокрытие реализации методов и др. типов предлагаю рассмотреть на простом примере.
Есть машина. Чтобы на ней ездить, водителям не надо знать, устройство двигателя, как происходит процесс процесс подачи топлива и кислорода, как происходит процесс горения топлива в цилиндрах и т.д.

>[!idea]+ Внимание!
>В целях ограничения доступа к полям используют свойства, которые представляют собой синтаксический сахар. Подробнее про свойства см. [[Свойства. Анонимные типы]]


## Наследование
---
Рассмотрим пример. Имеется класс `Person` с характеристиками `Name` и `Age`. Ещё имеется класс `Worker`, у которого также есть характеристики `Name` и `Age`, но есть ещё свойство `SNILS`. Также есть класс `WorkerIT`, у которого есть все свойства класса `Worker`, и ещё `LanguageP`. Чтобы не дублировать код в каждом классе придумали ***наследование***. При наследовании наследуются все поля, свойства и методы базового класса. Таким образом, при наследовании классу `Worker` передадутся все переменные, свойства и методы класса `Person`, останется только дописать свойство `SNILS`. Аналогичная ситуация и с наследованием класса `WorkerIT` от класса `Worker`, останется только дописать свойство `LanguageP`.
## Полиморфизм
---
Полиморфизм переводится как много форм. 
В C# есть параметрический полиморфизм, когда в метод с одинаковым названием и одинаковым типом возвращаемого значения передаётся параметры разного типа.

>[!idea]+ Внимание!
>В C# нельзя создавать методы с одинаковым названием и одинаковым типов входных параметров, но разным типов возвращаемого значения.

Второй тип полиморфизма связан с возможностью работать одному участку кода с разными типами. Тут можно привести использование обобщений (подробнее см. [[010. !!!Обобщения]]). Также сюда подходит использование интерфейсов, если в метод передаётся переменная интерфейсного типа, то в метод можно передать переменную любого типа, который реализует этот интерфейс.

## Абстрактный класс vs Interface
---
Абстрактный класс – тип, экземпляр которого нельзя создать. Даже с использованием приведения типов у нас ничего не выйдет. Наверное, следует сказать, что напрямую создать переменную типа абстрактного класса нельзя. Аналогичная ситуация у интерфейсов. Но переменную интерфейсного типа создать можно с помощью приведения типов или просто создав переменную типа, который реализует этот интерфейс.

>[!idea]+ Внимание!
>Абстрактный класс ***может содержать*** абстрактные методы, в то же время абстрактные методы ***могут существовать только*** в абстрактном классе.

Абстрактный класс может содержать абстрактные методы (помечены ключевым словом ***abstract***), т.е. методы без реализации, равно как и интерфейс содержит ***только*** методы без реализации. Однако, абстрактный класс может содержать и стандартные методы, в то же время интерфейсы лишены такой возможности.

Тип может наследоваться напрямую только от одного класса(в том числе абстрактного), а вот интерфейсов может реализовывать несколько.

>[!idea]
>Значимые типы не могут наследоваться от любого класса, кроме ***System.ValueType***. Следовательно, значимые типы не могут наследоваться от абстрактных классов, а реализовывать интерфейсы значимые типы вполне способны. Например, мы можем создать структуру, которая реализует один или несколько интерфейсов.

Использовать абстрактный класс следует, если мы хотим задать базовый функционал, а если мы хотим иметь обязательные характеристики и в дальнейшем выполнять работу, связанную именно с этой характеристикой, то выбираем интерфейс.




