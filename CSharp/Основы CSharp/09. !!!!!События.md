---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
завершена:
---
События – механизм, позволяющий уведомлять подписчиков при совершении каких-либо действий, при изменении состояния типа или объекта.
Определение события в типе означает, что тип поддерживает следующие возможности:
- регистрация заинтересованности в событии (имеется ввиду заинтересованности других типов в событии);
- отмена регистрации своей заинтересованности в событии;
- оповещение зарегистрированных объектов о совершённом событии.

Модель событий в CLR основана на ***делегатах*** a.k.a. методах обратного вызова           (***callback methods***). Делегаты позволяют подписываться на оповещения о совершённом событии.

Рассмотрим события на примере из книжки Рихтера:
1. имеется класс `MailManager`, существует только один экземпляр этого класса;
2. имеется класс `Fax`, который подписывается на событие;
3. при получении сообщения объектом класса `MailManager`, об этом оповещается объект класса `Fax`.

Внесу немного ясности. Порядок действий следующий:
1. Создаём экземпляр класса `MailManager` и `Fax`.
2. Подписываем объект типа `Fax `на событие объекта типа `MailManager`
3. Объект типа `MailManager` получает сообщение, о чём будут оповещены все объекты класса `Fax` (подписчики), подписавшиеся на событие.
## Разработка типа, поддерживающий событие
---
### Этап 1. Разработка типа для хранения дополнительной информации, передаваемой получателям события
------
При возникновении события, объект, в котором оно возникло, должен передать дополнительную информацию подписчикам. Для этого необходимо создать пользовательский класс, который будет содержать приватные поля, открытые свойства только для чтения. В соответствии с соглашением такой класс должен наследоваться от ***System.EventArgs*** и иметь название, заканчивающееся на *EventArgs*.

Для нашего примера напишем класс под названием `NewMailEventArgs`:
```
internal class NewMAilEventArgs : EventArgs {
	private readonly String _from, _to, _subject;
	
	public NewMailEventArgs(String from, String to, String subject) {
		_from = from;
		_to = to;
		_subject = subject;
	}
	
	public String From { get { return _from; } }
	public String To { get { return _to; } }
	public String Subject {get { return _subject; } }
}
```
### Этап 2. Определение члена события
---
Событие объявляется ключевым словом ***event***. Каждому члену-событию назначаются:
 1. область действия (почти всегда события открыты (`public`)). События можно вызвать из любой части кода, но события может вызвать <u>ТОЛЬКО</u> объект того типа, в котором описано событие;
 2. тип делегата, указывающий на прототип метода, которые могут подписаться на событие;
 3. имя (любой доступный идентификатор).
 
 В коде в нашем примере событие объявляется так:
```
public event EventHandler<NewMailEventArgs> NewMail;
``` 

Здесь `NewMail` – имя события, а `EventHandler<NewMailEventArgs>` – его тип. это означает, что подписчики должны предоставить метод обратного вызова, прототип которого соответствует прототипу-делегату `EventHandler<NewMailEventArgs>`. Обобщённый делегат ***System.EventHandler*** определён следующим образом:
```
public delegate void EventHandler<TEventArgs>(Object sender, TEventArgs e) where TEventArgs : EventArgs;
```
Поэтому прототип метода должен выглядеть следующим образом:
```
void MethodName(Object sender, NewMailEventArgs e) { } 
```

>[!attention]+ Внимание!
>1. Аргумент типа `...EventArgs` должен называться e, для обеспечения единообразия.
>
>2. Механизм события требует, чтобы все обработчики события возвращали `void`. Это обязательно, потому что при вызове события может выполняться несколько методов обратного вызова и невозможно получить все возвращаемые значения. Тип `void` просто запрещает вызов какого-либо значения.

### Этап 3. Определение метода, ответственного за уведомление подписчиков о событии
---
В соответствии с соглашением в классе должен быть виртуальный, защищённый (`protected`) метод, вызываемый из кода класса и его потомков при возникновении события. Этот метод принимает один параметр: `NewMailEvent`
```
protected virtual void OnNewMail(NewMailEventArgs e) {
	// Сохранить ссылку на делегата во временной переменной 
	// для обеспечения безопасности потоков
	EventHandler<NewMailEventArgs> temp = Volatile.Read(ref NewMail);
	// Если есть подписчики, то их уведомляем их
	if (temp != null) {
		temp(this, e);
	}
}
```


