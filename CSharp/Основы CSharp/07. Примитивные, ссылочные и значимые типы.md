---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
завершена: true
---
## Примитивные типы
---
Некоторые типы данных применяются так часто для некоторых задач, что для них сделали упрощённый синтаксис. Такие типы назвали ***примитивными***. Приведенный ниже код генерирует одинаковые IL-команды:
```
int a = 0;
Int32 a = new Int32();
```
Примитивные типы языка программирования C# указаны в таблице:

| Примитивный<br>тип | FCL-тип        | Совместимость<br>с CLS | Описание                                                                                                                                      |
| ------------------ | -------------- | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| sbyte              | System.Sbyte   | No                     | 8-разрядное значение со знаком (Signet bytе)                                                                                                  |
| byte               | System.Byte    | Yes                    | 8-разрядное значение без знака                                                                                                                |
| short              | System.Int16   | Yes                    | 16-разрядное значение со знаком                                                                                                               |
| ushort             | System.UInt16  | No                     | 16-разрядное значение без знака (Unsigned Int16)                                                                                              |
| int                | System.Int32   | Yes                    | 32-разрядное значение со знаком                                                                                                               |
| uint               | System.UInt32  | No                     | 32-разрядное значение без знака (Unsigned Int32)                                                                                              |
| long               | System.Int64   | Yes                    | 64-разрядное значение со знаком                                                                                                               |
| ulong              | System.UInt64  | No                     | 64-разрядное значение без знака (Unsigned Int64)                                                                                              |
| char               | System.Char    | Yes                    | 16-разрядный символ Unicode                                                                                                                   |
| float              | System.Single  | Yes                    | 32-разрядное значение с плавающей точкой в стандарте IEEE                                                                                     |
| double             | System.Double  | Yes                    | 64-разрядное значение с плавающей точкой в стандарте IEEE                                                                                     |
| bool               | System.Boolean | Yes                    | булевое значение (true or false)                                                                                                              |
| decimal            | System.Decimal | Yes                    | 128-разрядное значение с плавающей точкой повышенной точности, часто используемое для финансовых операций, где недопустимы ошибки округления. |
| string             | System.String  | Yes                    | массив символов                                                                                                                               |
| object             | System.Object  | Yes                    | базовый класс для всех типов                                                                                                                  |
| dynamic            | System.Dynamic | Yes                    | тип, позволяющий участвовать в динамическом разрешении типа с упрощённым синтаксисом????<br>Зачем он нужен, я не знаю, пусть просто будет.    |
Для работы с примитивными типами можно использовать примитивный или полный синтаксис.

## Проверяемые(checked) и непроверяемые(unchecked) операции
---
Рассмотрим такой пример кода:
```
byte b = 200;
b = b + 100;
```
В результате в переменную b поместится значение 200 + 100 = 300, что превышает максимальный размер для переменной типа byte. На самом деле в b поместится значение 44 (300 - 256), а ошибка переполнения (*OverflowException*) не будет выброшена, потому что по умолчанию указан параметр */checked-*, который указывает на использование команд без проверки переполнения (недополнения). 

Для самостоятельного выбора проверяемого/непроверяемого кода в С# используются ключевые слова ***checked*** и ***unchecked***:
```
byte b = 200;
b = checked((byte)(b + 100)) // Выбросится исключение OverflowException

unchecked 
{
   uint i = -1; // Ошибка не будет выброшена
}
```

> [!attention]+ !
>Особняком стоит примитивный тип Decimal. Если для примитивных типов могут использоваться команды с проверкой или без проверки переполнения, то для операций с типом decimal вызываются его собственные команды, в которых отсутствует проверка переполнения, таким образом использование ключевых слов ***checked*** и ***unchecked*** с переменными типа decimal ***бессмысленно***.  

## Ссылочные(refference) и значимые(value) типы
---
***Ссылочными*** называют типы, которые передаются ***по ссылке***.
При работе с ***ссылочными*** типами следует помнить:
- память для ссылочных типов всегда выделяется из управляемой кучи;
- каждый объект, размещаемый в куче содержит дополнительные члены, подлежащие инициализации;
- незанятые полезной информацией байты объекта из управляемой кучи обнуляются;
- размещение объекта в управляемой куче со временем инициирует сборку мусора.

Если бы все типы были ссылочными, то производительность приложения резко упала. Поэтому чтобы ускорить обработку часто используемых в CLR типов, были созданы "<font color="#e36c09">облегчённые</font>" ***значимые*** типы. Экземпляры значимых типов обычно хранятся в стеке потока, а значения полей объекта хранятся в самой переменной.

> [!attention]+ !
> Благодаря тому, что экземпляры значимых типов не обрабатываются сборщиком мусора, количество взаимодействий с управляемой кучей снижается, что позитивно сказывается на производительности приложения.

В C# <font color="#e36c09">классы</font> относят к ***ссылочным*** типам, а <font color="#e36c09">структуры</font> и <font color="#e36c09">перечисления</font> – к ***значимым***.

Продемонстрируем ***различие*** между ссылочными и значимыми типами:

```
class SomeRef { public Int32 x; }

struct SomeVal { public Int32 x; }

static void ValueTypeDemo(){

SomeRef r1 = new SomeRef(); // Размещается в куче
SomeVal v1 = new SomeVal(); // Размещается в стеке 

r1.x = 5; // Изменение объекта в куче 
v1.x = 5; // Изменение объекта в стеке

Console.WriteLine(r1.x); // 5
Console.WriteLine(v1.x); // 5

SomeRef r2 = r1; // Копируется только ссылка (указатель)
SomeVal v2 = v1; Помещаем в стек и копируем члены

r1.x = 8; // Изменяются r1 и r2
v1.x = 9; // Изменяется только v1

Console.WriteLine(r1.x) // 8
Console.WriteLine(r2.x) // 8
Console.WriteLine(v1.x) // 9
Console.WriteLine(v2.x) // 5
}
```

> [!attention]+ Внимание
> Основное достоинство значимых типов состоит в том, что они обычно не хранятся в управляемой куче.

## Отличия между ссылочными и значимыми типами
---
1.  Объекты значимого типа могут находиться в двух формах: ***упакованной*** и ***неупакованной***. Объекты ссылочного типа могут находиться только в "***упакованной***" форме.
2. Значимые типы являются производными от класса <font color="#e36c09">System.ValueType</font>. Этот тип имеет те же методы (см. [[04. Основы типов]]), что и <font color="#e36c09">System.Object</font>. Однако <font color="#e36c09">System.ValueType</font> переопределяет метод ***Equals()***, который возвращает *true*, если значения полей объектов совпадают. <font color="#e36c09">System.ValueType</font> также переопределяет метод ***GetHashCode()***, который возвращает хеш-код объекта в зависимости от значения полей объекта.
3. Поскольку в объявлении нового значимого или ссылочного типа <font color="#de7802">нельзя указывать значимый тип в качестве базового</font>, создавать в базовом значимом типе виртуальные поля и методы нельзя. Методы не могут быть абстрактными и неявно считаются запечатанными.
4. Переменные ***ссылочного типа*** содержат адреса объектов в куче. Когда переменная ссылочного типа создаётся, ей по умолчанию присваивается ***null***, то есть в данный момент она не указывает на действительный объект. Попытка обращения к такому объекту приведёт к ошибке <font color="#e36c09">NullReferenceException</font>. В то же время в переменной ***значимого типа*** всегда хранится некоторое значение, а при инициализации всем полям присваивается 0. Поскольку переменная значимого типа не является указателем, при попытке взаимодействия с такой переменной ошибки <font color="#e36c09">NullReferenceException</font> не будет.
5. Когда переменной ***значимого типа*** присваивается значение другой переменной, выполняется копирование ***всех её полей***. Когда переменной <font color="#de7802">ссылочного типа</font> присваивается переменная, копируется только <font color="#de7802">её адрес</font>.
6. Вследствие сказанного в п. 5 несколько объектов значимого типа могут ссылаться на 1 область памяти, тогда при изменении одной переменной будут изменены все объекты, указывающие на эту область памяти. В то же время объекты значимого типа "***копируются***" и при изменении одной переменной остальные не будут затронуты.
7. Так как неупакованные значимые не размещаются в куче, отведённая для них память освобождается сразу после возвращения управления методом, в котором описан экземпляр значимого типа.
## Упаковка(boxing) и распаковка(unboxing) значимых типов
---
Значимые типы "легче" ссылочных: для них не нужно выделять память в управляемой куче, их не затрагивает сборка мусора, к ним нельзя обратиться через указатель. Однако часто требуется получать ссылку на экземпляр значимого типа, например, если мы хотим сохранить структуры Point в объекте типа ArrayList:
```
struct Point {
  public int x, y; 
}
public sealed class Program {
	public static void Main(string[] args) {
	ArrayList a = new ArrayList();
	Point p;
	for (int i = 0; i < 10; i++){
		p.x = p.y = i;
		a.Add(p);
		}
	}
}
```
Прототип метода Add класса ArrayList выглядит следующим образом:
```
public virtual Int32 Add(object o)
```
Отсюда видно, что в качестве параметра выступает переменная типа ***object***, то есть она имеет ссылочный тип. Как же передать в этот метод переменную значимого типа? Для представления значимых типов в виде ссылочных можно применить ***упаковку(boxing)***. При упаковки экземпляра значимого типа происходит следующее:
- В управляемой куче выделяется память. Её объем определяется длиной значимого типа и двумя дополнительными членами – указателем на объект тип и индексом блока синхронизации. Эти члены необходимы для всех объектов в управляемой куче.
- Поля значимого типа копируются в память, только что выделенную в управляемой куче.
- Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть создаётся объект ссылочного типа, который хранит в себе значение значимого типа.

Перейдём к ***распаковке(unboxing)***:
```
Point p = (Point) a[0];
```
Здесь ссылка (или указатель), содержащаяся в элементе под номером 0 ссылочного типа ArrayList, помещается в переменную значимого типа Point. Для этого необходимо скопировать все поля, содержащиеся в упакованном объекте Point, в переменную `p` значимого типа, находящуюся в стеке потока. CLR выполнит эту процедуру в 2 этапа. Сначала извлекается адрес полей Point из упакованного объекта Point. Затем значения полей копируются из кучи в экземпляр значимого типа, хранящегося в стеке.

Распаковка не является точной противоположностью упаковки. Она менее ресурсозатратна, чем упаковка, и заключается только в получении указателя на исходный значимый тип (поля данных), содержащийся в объекте. В сущности, указатель ссылается на неупакованную часть упакованного экземпляра, и никакого копирования при распаковке не происходит. Однако, после распаковки может следовать копирование полей объекта. Так написано в Рихтере, но я не совсем согласен. ***Распаковка*** – процесс копирования значения полей объекта значимого типа, хранящегося в куче, в переменную значимого типа.  

> [!attention]+ !
> В состав FCL входит новое множество обобщённых классов коллекций, из-за которых необобщённые классы коллекций считаются устаревшими. Так, вместо класса ArrayList следует использовать его обобщённый аналог <font color="#de7802">System.Collections.Generic.List<=T=></font>. Обобщённые аналоги во многом совершеннее своих необобщённых аналогов. <font color="#e36c09">А главный плюс обобщённых коллекций заключается в возможности работы с объектами значимых типов без необходимости упаковки/распаковки объектов значимых типов, что позитивно сказывается на производительности</font>. 

