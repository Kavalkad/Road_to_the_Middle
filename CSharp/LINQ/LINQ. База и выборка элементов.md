---
tags:
  - CSharp
  - IT
Источник: METANIT
date: 2025-09-04
завершена: true
---
## Общая информация
---
***LINQ – Language Integrated Query*** или язык интегрированных запросов. 
Технология LINQ позволяет проводить операции с коллекциями в виде запросов.

Существует 2 способа применения LINQ: в виде ***запросов*** и в виде ***методов***.
Допустим есть коллекция:
```
string[] people = {"Tom", "Bob", "Sam", "Tim", "Tomas"};
```
Запрос будет выглядеть примерно так:
```
var sortedPeople = from p in people
				   where p.StartWith("T")
				   orderby p
				   select p;
```
Разберём каждую строчку. 
- `from p in people` – для каждого элемента `p` в коллекции `people`
- `where p.StartWith("T")` – выбрать элементы, начинающиеся на `"T"`
- `orderby p` – отсортировать по значению `p`
- `select p` – в итоговую коллекцию добавить `p`
Общий вид запроса выглядит так:
```
from item in collection
where (boolean condition)
...
select (final element)
```

Теперь разберём вид методов:
```
var sortedPeople = people.Where(p => p.StartsWith('T')).OrderBy(p => p);
```
Список используемых методов Linq:
- `Select(item)` – выбираем в итоговую коллекцию элемент `item`
- `Where(boolean expr)` – делаем выборку в коллекции по признаку `expr`
- `OrderBy(item)` – упорядочиваем по возрастанию по соответствующему элементу `item`
- `OrderByDescending(item)` – упорядочиваем по убыванию по соответствующему элементу `item`
- `Join()` – <span style="background:#d4b106">соединяем две коллекции по определённому признаку</span>
- `Agregate` – <span style="background:#d4b106">применяет к элементам коллекции агрегатную функцию, которая сводит их в один объект </span>
- `GroupBy` – группирует элементы по ключу
- `ToLookUp` – <span style="background:#d4b106">группирует элементы по ключу, при этом все элементы добавляются в словарь</span>
- `GroupJoin` – выполняет одновременно соединение коллекций и группировку элементов по ключу
- `Reverse`  – располагает элементы в обратном порядке
- `All` – определяет, все ли элементы удовлетворяют условию
- `Any` – определяет, удовлетворяет ли условию хотя бы один элемент
- `Contains(T element)` – определяет, содержит ли коллекция `element`
- `Distinct` – удаляет повторяющиеся элементы
- `Except` – возвращает разность двух коллекций, то есть коллекцию из элементов, которые есть только в одной коллекции
- `Union` – <span style="background:#d4b106">объединяет две однородные коллекции</span>
- `Intersect` – возвращает пересечение двух коллекций, то есть коллекцию из элементов, которые есть в обеих коллекциях
- `Count` – подсчитывает количество элементов, удовлетворяющих определённому условию
- `Sum` – подсчитывает сумму числовых значений в коллекции
- `Average` – подсчитывает среднее арифметическое элементов в коллекции
- `Min` – находит минимальное значение в коллекции
- `Max` – находит максимальное значение в коллекции
- `Take` – выбирает определённое количество элементов
- `Skip` – пропускает определённое количество элементов
- `TakeWhile` – возвращает цепочку элементов коллекции пока условие истинно
- `SkipWhile` – пропускает элементы в коллекции, пока они удовлетворяют условию, и возвращает оставшиеся элементы
- `Concat` – объединяет две коллекции
- `Zip` – объединяет две коллекции в соответствии с определённым условием
- `First` – возвращает первый элемент коллекции, который удовлетворяет условию
- `FirstOrDefault` – возвращает первый элемент коллекции, который удовлетворяет условию или значение по умолчанию
- `Single` – выбирает единственный элемент, удовлетворяющий условию. Если коллекция содержит больше одного или не содержит вовсе искомого элемента, то генерируется исключение
- `SingleOrDefault` – возвращает единственный элемент коллекции, если он единственный, в ином случае возвращает значение по умолчанию
- `ElementAt` – выбирает элемент коллекции по индексу
- `ElementAtOrDefault` – выбирает элемент по индексу. Если индекс находится вне допустимого диапазона, то возвращается значение по умолчанию
- `Last` – возвращает последний элемент коллекции
- `LastOrDefault` – возвращает последний элемент коллекции или возвращает значение по умолчанию
## Проекция элементов
---
Проекция позволяет преобразовать элементы коллекции в другие элементы. 
Для прояснения ситуации рассмотрим пример.
У нас есть класс `Person`, который имеет свойство `Name`. 
Имеется такая коллекция:
```
var list = new List<Person>() { new Person { Name = "Andy"},
                                new Person { Name = "Candy"},
                                new Person { Name = "Sandy"}};
```
Мы хотим получить коллекцию ***имён*** данных имён. Для этого подойдёт такой запрос:
```
from p in list
select p.Name;
```

На языке методов мы можем использовать метод ***Select(Func<TSource, TResult> selector)***, и итоговый код будет выглядеть так:
```
var names = list.Select(p => p.Name);
```

Также результатом проекции могут быть экземпляры анонимного типа:
```
var names = from n in list
			select new { n.Name };
```
Или на языке методов:
```
var names = list.Select(n => new { n.Name });
```
В приведённом примере создаются экземпляры анонимного типа со свойством `Name`, которое хранит значение `n.Name`.
## Промежуточные переменные
---
Иногда возникает необходимость использовать в запросах промежуточные вычисления. Для этих целей есть ключевое слово ***let*** в запросах:
```
var names = from n in list
            let name = n.Name
            select name;
```
## Выборка элементов из нескольких источников
---
В LINQ можно выбирать объекты из ***нескольких*** источников. 
Предположим, есть 2 класса:
```
 public class Student
        {
            public string? Name { get; set; }
            public Student(string name)
            {
                Name = name;
            }
        }
        public class Course
        {
            public string? Title { get; set; }
            public Course(string title)
            {
                Title = title;
            }
        }
```
Мы хотим получить список в виде студент – курс. 
На языке запросов получим такой код:
```
var enrollments = from c in courses
                  from s in students
                  select new { Student = s.Name, Course = c.Title };
```
Таким образом будет создана коллекция элементов анонимного типа со свойствами `Student` и `Course`, в которых будут храниться значения имени студента (`s.Name`) и названия курса (`c.Title`) соответственно.
Написать этот же запрос на языке методов у меня пока не получается.
## SelectMany и сведение объектов
---
Метод ***SelectMany*** позволяет свести несколько коллекций в одну коллекцию. 
Он имеет несколько перегруженных версий:

SelectMany ***`(Func<TSourse, IEnumerable<TResult>> selector)`***
SelectMany ***`(Func<TSourse, IEnumerable<TCollection>> collectionSelector, Func<TSourse, TCollection, TResult) resultSelector)`***

В первом случае метод принимает функцию преобразования в виде делегата ***`Func<TSource, IEnumerable<TResult>> selector`***. Функция преобразования получает каждый объект типа ***TSource*** и на его основе возвращает коллекцию ***`IEnumerable<TResult>`***. 
Рассмотрим пример. Имеется такой код:

Описание классов ***Company*** и ***Staff*** выглядит следующим образом:
```
public class Company
        {
            public string? Name;
            public List<Staff>? Staff;

            public Company(string name, List<Staff> staff)
            {
                Name = name;
                Staff = staff;
            }
        }
        public class Staff
        {
            public string? Name;
            
            public Staff(string name)
            {
                Name = name;
            }
        }
```
И имеется такой код:
```
var companies = new List<Company>
            {
                new Company("Kommunarka", new List<Staff>() { new Staff("Andy"),
                                                              new Staff("Candy"),
                                                              new Staff("Sandy")}),

                new Company("Apple", new List<Staff>(){ new Staff("Steve"),
                                                        new Staff("Jacob"),
                                                        new Staff("Lewis")})

            };

var staff = companies.SelectMany(s => s.Staff); 
  
foreach (var name in staff)
            {
                Console.WriteLine($"{name.Name}");
            }
```
В строчке ***`var staff = companies.SelectMany(s => s.Staff);`*** в переменную ***`staff`*** помещается коллекция объектов класса ***`Staff`***, которая в классе ***`Company`*** обозначена свойством  ***`Staff`*** типа ***`List<Staff>?`***. Таким образом, в переменной ***`staff`*** лежит коллекция типа ***`IEnumerable<Staff>`*** и содержит имена сотрудников двух компаний. Затем в цикле ***`foreach`*** мы выводим каждый элемент в консоль.
Теперь давайте поиграемся и что-нибудь поломаем).
- Если мы в строчке ***`var staff = companies.SelectMany(s => s.Staff);`*** обратимся не к свойству ***`Staff`***, а  к свойству ***`Name`*** класса ***`Company`***?
  Свойство ***`Name`*** класса ***`Company`*** имеет тип ***`string`***, который представляет собой набор символов, то есть коллекцию элементов типа ***`char`***. Мы должны получить коллекцию символов, то есть объектов типа ***`char`***. Итоговый код будет отличаться только строчкой: ***`var chars = companies.SelectMany(s => s.Name);`***. По итогу получим вывод каждого символа двух названий в консоли.
- Если в строчке ***`Console.WriteLine($"{name.Name}");`*** не написать свойство ***`Name`***?
  Мы уже выяснили, что в переменной ***`staff`*** хранятся объекты типа ***`Staff`***. При передачи такого объекта в консоль получим ***6 выводов полных называний класса `Staff`***. 
Такой же результат можно получить на языке запросов:
```
var staff = from c in companies
			from s in c.Staff
			select s;
```

Теперь добавим к сотрудникам их компании, используя второй перегруженный метод ***`SelectMany(Func<TSourse, IEnumerable<.TCollection>> collectionSelector, Func<TSourse, TCollection, TResult) resultSelector)`***. 
Код с использованием этого метода выглядит так:
```
var namesAndCompany = companies.SelectMany(s => s.Staff, 
										   (c,s)=> new { s.Name, name = c.Name} );
```
Здесь в первой части – ***`s => s.Staff`***, создаётся единая коллекция, в которую передаётся свойство типа ***`List<Staff>`*** объектов класса ***`Company`*** т.е. коллекция объектов класса ***`Staff`***.  Затем, коллекция из первой части попадает ***во вторую часть*** в данном случае это переменная ***`s`***, а ***первый элемент*** имеет такой же тип, как и объект ***`s`*** из первой части. 
Получилось как-то запутанно, поэтому я перепишу немного эту часть:
```
var namesAndCompany = companies.SelectMany(s => s.Staff, 
										   (s,c)=> new { c.Name, name = s.Name} );
```
То есть назвать переменные, которые в примере выше подписаны как ***`s`*** и ***`c`*** можно как угодно, но по смыслу лучше этот вариант. 
