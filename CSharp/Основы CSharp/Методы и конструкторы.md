---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
завершена: true
---
***Конструктор*** – метод, корректно инициализирующий экземпляр данного типа.
## Конструкторы экземпляров классов
---
При создании экземпляра объекта ссылочного типа выделяется память для полей объекта и для служебных полей (указателя на объект-тип и индекс блока синхронизации). При конструировании объекта ссылочного типа выделяемая для него память обнуляется до вызова конструктора экземплярного типа. Если в конструкторе экземплярного типа значение полей не изменяется, им гарантировано присваивается значение **null** для поля ссылочного типа и **0** для поля значимого типа.

>[!idea]+ !
>Конструкторы не наследуются. Поэтому с ними нельзя использовать ключевые слова ***abstract***, ***sealed***, ***virtual***, ***new***, ***override***.

В типе может определяться несколько конструкторов, при этом ***сигнатуры*** и типы доступа(???) ***должны отличаться***.

>[!idea]+ !
>Экземпляр типа можно создать и без использования конструктора. Например, при использовании метода ***MemberwiseClone()***, а также ***десереализации***.  

Предположим, что имеется такой тип:
```
public class SomeClass {
	private Int32 x = 5;
}
```

При вызове конструктора данного класса сначала будут проинициализированы экземплярные и служебные поля. Затем будет вызван конструктор базового типа (в данном случае будет вызван конструктор класса ***System.Object***, который просто возвращает управление). После вызова конструктора базового класса будет выполнен код, написанный в теле конструктора.

>[!attention]+ Внимание! 
>Не следует использовать виртуальные методы в конструкторе, потому что вызываемый метод может быть переопределён в производном классе (классе, конструктор которого сейчас реализуется). Вызов такого метода в середине тела конструктора до инициализации всех полей объекта может привести к непредсказуемым последствиям. 

При наличии нескольких экземплярных полей необходимо быть готовым к разрастанию кода:
```
internal sealed class SomeType {
	private int x = 5;
	private string s = "Hi";
	private bool b = false

	//А это конструкторы
	public SomeType() {...}
	public SomeType(int i) {...}
	public SomeType(bool b) {...}
}
```

При наличии ***большого количества полей*** проблема разрастания кода ***станет всё больше***. Проблема разрастания кода решается инициализацией полей значениями по умолчанию в конструкторе без параметров и ***явным вызовом конструктора без параметром*** данного типа:
```
public SomeType() {
	x = 15;
	s = "Hello Bro";
	b = true;
}

public SomeType(int i) : this() { this.x = i }
public SomeType(bool b) : this() { this.b = false }
```

>[!idea]
>Для решения проблемы разрастания кода можно использовать в конструкторе значения полей по умолчанию.

## Конструкторы экземпляров структуры
---
>[!idea]+ !
>CLR всегда разрешает создание экземпляров значимых типов.

Рассмотрим следующий код:
```
internal struct Point {
	public int p_x, p_y;
	
	public Point(int x, int y) {
		p_x = x;
		p_y = y;
	}
}

internal sealed class Rectangle {
	public Point topLeft, topRight;
}
```
 В данном коде для создания объекта Rectangle надо проинициализировать 2 поля типа Point. Казалось бы, должен вызваться конструктор. Но в целях оптимизации конструктор значимых типов не вызывается. Для вызова конструктора значимого типа необходимо его явно вызвать:
```
internal struct Point {
	public int p_x, p_y;
	
	public Point(int x, int y) {
		p_x = x;
		p_y = y;
	}
}

internal sealed class Rectangle {
	public Point topLeft, topRight;
	
	public Reactangle() {
		topLeft = new Point(1, 2);
		topRight = new Point(10, 20);		
	}
}
```

>[!attention]+ !
>C# не позволяет создавать конструктор значимого типа без параметров.

## Перегруженные операторы
---
В C# при попытке суммировать 3 и 5 получим 8, при попытке суммировать 2 строки, получим результат конкатенации этих строк("abc" + "def" = "abcdef"). А что если мы захотим суммировать 2 объекта пользовательского типа? Это демонстрирует следующий код:
```
Point p1 = new Point(1, 2);
Point p2 = new Point(10, 20);

Point p3 = p1 + p2;
```
В результате этот код даже не скомпилируется, потому что компилятор не умеет суммировать пользовательские типы. Для решения этой проблемы существует ***перегрузка операторов***. В коде она выглядит вот так:
```
public sealed class Point {
	public static Point operator + (Point p1, Point p2) {...}
}
```
В C# данный метод должен быть статическим (`static`) и хотя бы 1 из операндов должен иметь тип, в котором определён метод. В данном случае хотя бы 1 из операндов должен иметь тип Point.

## Методы расширения
---
***Метод расширения*** – статический метод, который может вызываться как экземплярный. В коде метод расширения выглядит так:
```
public static Int32 IndexOf(this StringBuilder sb, char ch) {...}
```

Теперь мы можем вызвать этот метод следующим образом:
```
var sB = new StringBuilder("Hello");
Int32 index = sB.IndexOf('H');
```
Подытожим, мы создали статичный метод, который используется как экземплярный. Для вызова данного метода мы создали экземпляр класса `StringBuilder` и через точку вызвали метод.

### Правила и рекомендации
---
1. C# поддерживает только ***методы*** расширения, а не свойства расширения, события расширения и т.д.
2. Методы расширения должны быть написаны ***в статическом необобщённом классе***.
3. Компилятор C# ищет методы расширения только в статических классах, определённых в области видимости программы. Для добавления новой области в область видимости программы используйте директиву ***using*** в начале файла.
4. Существует возможность создания двух одинаковых методов расширения в двух различных статических классах. Тогда мы получим ошибку *CS0121*. Для её исправления придётся менять программный код: при вызове метода придётся отказаться от экземплярного вызова и использовать вызов с указанием статического класса нужного метода.
## Расширение разных типов методами расширения
---
Методы расширения могут использоваться для ***интерфейсов***, ***делегатов*** и др.
Пример использования метода расширения для интерфейса:
```
public static void ShowItems(this IEnumerable<T> collection) {
	foreach (var item in collection) {
		Console.WriteLine(item);
	}
}
```

>[!attention]+ Внимание!
>Необходимо помнить, что методы расширения являются статическими и при вызове такого метода проверка объекта, вызвавшего метод, на ***null*** не проводится.
>```
>StringBuilder sb = null;
>sb.IndexOf('a');
>```
>В данном примере при вызове метода ошибка не будет выброшена. Ошибка будет выброшена внутри метода.

Пример использования метода расширения для делегата:
```
public static void InvokeAndCatch<TException>(this Action<object> d, Object o)
										  where TException : Exception {
	try { d(o); }
	catch (Exception) {}
}

Action<object> action = (o) => Console.WriteLine(o.GetType()); // Получаем NullReferenceException
action.InvokeAndCatch<NullReferenceException>(null) // Поглощаем NullReferenceException 
```
