---
tags:
  - CSharp
  - IT
Источник: Дж. Рихтер CLR via C#
завершена: true
---
## Необязательные и именованные параметры 
---
При выборе параметров метода некоторым из них (или даже всем) можно присвоить значение по умолчанию. В коде это выглядит примерно так:
```
private sealed class Program {
	private static Int32 s_n = 8;
	private static M(Int32 x = 22, String s = "Строка", 
					DateTime dt = default (DateTime), 
					Guid g = new Guid) {
		Console.WriteLine($"{x}, {s}, {dt}, {g}")
	}
	static void Main(string[] args) {
		M();
		M(25, "Привет") // 25, "Привет", 1/1/0001 12:00:00 AM, 0000000...
		M(g: Guid.NewGuid(), dt: DateTime.Now)
	}
}
```
В третьем вызове я <u>явно</u> указал значение переменных. Эти переменные называются ***именованными параметрами***. 
## Правила использования параметров
---
1. Значения по умолчанию можно определять для методов, конструкторов методов, и параметрических свойств (см. [[08. Свойства. Анонимные типы]]). Также их можно использовать для параметров, являющихся частью определения делегатов. В результате параметры делегата можно опускать и использовать значения по умолчанию.
2. Параметры со значением по умолчанию должны следовать после всех остальных параметров. Имеется *одно* исключение: когда нам надо передать массив параметров – ключевое слово ***params***. При этом сам массив значений по умолчанию иметь не может.
3. Во время компиляции значения по умолчанию должны оставаться ***неизменными***. То есть значениями по умолчанию могут выступать ***примитивные типы***, ***ссылочные типы***, поддерживающие значение ***null***, ***произвольные значимые типы***. В случае произвольных значимых типов значением по умолчанию будет экземпляр значимого типа, все поля которого будут содержать 0.
4. ***Запрещается переименовывать*** значения по умолчанию, так как это влечёт за собой изменение вызывающего кода, который передаёт переменные по имени параметра.
5. Для параметров, помеченных ключевыми словами ***ref*** и ***out*** значения по умолчанию не задаются.

Существуют также правила вызова методов с именованными параметрами:
1. Аргументы можно передавать <font color="#e36c09">в произвольном порядке</font>, но именованные аргументы должны находиться<font color="#e36c09"> в самом конце</font>.
2. Передача аргумента по имени возможна для параметров, не имеющих значение по умолчанию, но при этом компилятору должны быть переданы все необходимые аргументы.
3. В C# <font color="#e36c09">между запятыми</font> не могут отсутствовать аргументы.
4. Вот как задать именованный параметр для аргументов, помеченных ключевыми словами ***ref/out***: 
```
private static void M(ref Int32 x) {...}
Int32 z = 2
M(x: ref z)
```
## Передача параметров в метод по ссылке. Ключевые слова ref и out
---
При передаче в качестве параметра метода объект <font color="#e36c09">ссылочного типа</font> в метод передаётся <font color="#e36c09">ссылка</font> на объект, и метод может изменять состояние объекта в памяти. Если в качестве параметра метода передаётся объект <font color="#e36c09">значимого типа</font>, то методу передаётся <font color="#e36c09">копия объекта</font>, и код может воздействовать только на копию объекта, а не на сам объект.

В C# можно передавать все объекты по ссылке, независимо от его типа. Для этого служат ключевые слова ***ref*** и ***out***. 

Если параметр помечен ключевым словом ***ref***, то он <font color="#e36c09">должен быть проинициализирован</font> <font color="#e36c09">до вызова метода</font>, в который передаётся параметр. Пример кода с использованием ***ref*** приведён ниже:
```
Int32 x = 10;
AddVal(ref x);
Console.WriteLine(x); // 20

public void AddVal(ref int x) {
	x += 10;
}

```
Здесь в качестве параметра передаётся объект типа Int32, т.е. значимого типа, но помеченный ключевым словом ***ref***. До вызова метода в стеке вызовов проинициализирован объект – число 10. В метод передаётся ссылка на область стека, в которой хранится объект. В коде метода мы увеличили значение переменной на 10, а затем вывели результат (20) в консоль.

Если параметр помечен ключевым словом ***out***, то он <font color="#e36c09">может быть не проинициализирован до вызова метода</font>, но он <font color="#e36c09">обязан быть проинициализирован или изменён</font> в теле метода. Пример кода с использованием ключевого слова ***out*** приведён ниже:
```
GetVal(out x);
Console.WriteLine(x.ToString());

GetVal(out Int32 z) {
	z = 10;
}
```

>[!idea]+ !
>Параметр, помеченный ключевым словом ***out***, можно использовать после вызова метода.

>[!idea]+ !
>В C# можно перегружать методы с ключевым словом ***ref/out*** и без него:
>```
>static void Add( Point p ) { ... }
>static void Add ( ref/out Point p) { ... }
>```
>Но перегружать методы с ключевым словом ***ref*** и ***out*** одновременно нельзя:
>```
>static void Add( ref Point p) { ... }
>static void Add( out Point p) { ... } // CS0663: Add cannot define overload method that differ only ref and out
>```

Со значимыми типами ключевые слова ***ref*** и ***out*** дают такой же результат, как и с ссылочными типами. В теле метода код взаимодействует с единственным экземпляром значимого типа. А что будет, если с ключевым словом ***ref*** или ***out*** передать объект ссылочного типа?

В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим указателем. В силу этих особенностей использование ключевых слов ***ref***  и ***out*** с объектами ссылочного типа целесообразно лишь в случае, когда метод собирается вернуть ссылку на известный ему объект. Рассмотрим на примере:
```
using System;
using System.IO;

public sealed class Program {
	public static void Main(string[] args) {
		FileStream fs;
		
		StartProccessingFile(out fs);
		
		
		private static void StartProccessingFile(out FileStream fs) {
			fs = new FileStream(...);
		}
		
		private static void ContinueProccessingFile(out FileStream fs) {
			fs.Close();
			
			if (NoMoreFilesToProccess) fs = null;
			else fs = new FileStream(...);
		}
	}
}
```

## Передача переменного количества параметров (params)
---
Для передачи переменного количества параметров существует ключевое слово ***params***. В коде использование ключевого слова ***params*** выглядит так:
```
static Int32 Add(params Int32[] array) {
	Int32 sum = 0;
	if (array != null) {
		foreach (var item in array) {
			sum += item;
		}
	}
	return sum;
}
```

>[!attention]+ !
>Ключевое слово ***params*** применяется только к последнему параметру метода.
>

Описанный выше метод Add() можно вызвать следующим образом:
```
private sealed class Program {
	static void Main (string[] args) {
		Console.WriteLine(Add(1, 2, 3, 4)); // 10
	}
}
```
