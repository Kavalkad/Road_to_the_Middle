---
tags:
  - CSharp
  - IT
Источник: METANIT
date: 2025-09-05
завершена: true
---
## Общая информация
---
Метод ***Where*** выглядит следующим образом: ***`Where<TSource,bool> predicate`***
Этот метод принимает в качестве параметра каждый элемент коллекции и возвращает ***bool***. Если элемент соответствует условию, то элемент добавляется в результирующую коллекцию.
Рассмотрим пример:
```
 List<string> people = new List<string>() { "Tom", "Bob", "Sam", "Tim", "Tomas" };

 var shortNames = people.Where(n => n.Count() == 3);
 
 foreach (var name in shortNames)
	{
		Console.WriteLine(name);
	}
```
В результате выполнения этого кода мы получим вывод всех имён из списка ***`people`***, которые состоят из трёх символов.

Аналогичный результат мы получим при использовании кода в виде запросов:
```
var shortNames = from p in people
				 where p.Count() == 3
				 select p
```
## Выборка сложных объектов
---
Предположим, у нас есть такой класс ***`Person`***:
```
public class Person
        {
            public string? Name { get; set; }
            public int Age { get; set; }
            public List<string>? Languages { get; set; }

            public Person(string name, int age, List<string> languages)
            {
                Name = name;
                Age = age;
                Languages = languages;
            }
        }
```
Создадим список объектов ***`Person`***:
```
List<Person> people = new List<Person>() { 
		     new Person("Andy", 23, new List<string>(){"russian", "english"}),
             new Person("Candy", 43, new List<string>(){"russian, german"}),
             new Person("Cenderella", 32, new List<string>(){"english", "german"})};
```
И выберем всех людей, чей возраст больше 25. На языке методов получим такой код:
***`var oldPeople = people.Where(p => p.Age > 25);`***
И на языке запросов:
```
var oldPeople = from p in people
				where p.Age > 25
				select p;
```
## Более сложные фильтры
---
Давайте отфильтруем людей по владению русского языка и возрасту больше 30.
Вспомним, что языки у объектов ***`Person`*** представлены в виде списка (***`List<string>`***). Напишем запрос на языке методов. Используем метод ***`SelectMany`***, который принимает коллекцию коллекций:
```
var russians = people.SelectMany(l => l.Languages, (p, l) => new { Person = p, Language = l })
                                    .Where(a => a.Language == "russian" && a.Person.Age > 40)
                                    .Select(p => p.Person.Name)
```
Разберём подробнее. Сначала в первой части ***`l => l.Languages`*** мы получаем *единую* коллекцию из языков, затем во второй части анонимный метод принимает *ту же коллекцию, которую он принимал в первой части* и *коллекцию, которая была получена в первой части*. Потом в теле анонимного метода создаётся объект анонимного типа со свойством типа ***`Person`*** и свойством типа ***`string`***. Затем из полученной коллекции объектов анонимного типа выбираются те, у которых свойство ***`Language== "russian"`*** и ***`&& a.Person.Age > 40`***, и в итоговую коллекцию помещаются имена: ***`Select(p => p.Person.Name)`***. 

Аналогичный результат мы получим при написании такого запроса:
```
var russians = from p in people
				from l in p.Languages
				where l == "russan" && p.Age > 40
				select p.Name;
```
## Фильтрация по типу данных. Метод OfType
---
Метод расширения ***`OfType<SomeType>()`*** позволяет записать в итоговую коллекцию элементы типа ***`SomeType`***:
Описание классов выглядит так:
```
    record class Person(string Name);
    record class Student(string Name) : Person(Name);
    record class Employee(string Name) : Person(Name);
```
А вызов метода выглядит так:
```
var list = new List<Person>()
            {
                new Person("Andy"),
                new Student("Candy"),
                new Person("Sandy"),
                new Employee("Mandy")
            };
            
            var persons = list.OfType<Student>();
            foreach (var p in persons)
            {
                Console.WriteLine(p.Name);
            }
```
Мы уже достаточно большие мальчики и девочки, чтобы понять этот код самостоятельно.